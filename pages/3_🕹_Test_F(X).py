‡πÅ‡∏ô‡πà‡∏ô‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö!  
‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡∏Ñ‡∏∑‡∏≠ **‡πÇ‡∏Ñ‡πâ‡∏î Streamlit ‡∏â‡∏ö‡∏±‡∏ö‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå** ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö **Best Seed Sliding Window (‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà)**  
‡πÇ‡∏î‡∏¢‡∏à‡∏∞‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÅ‡∏Ñ‡πà 2 Tabs:  
- ‚öôÔ∏è ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤  
- üöÄ New Model (Near Perfect Foresight)  
‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå **Dynamic Threshold Rebalancing** ‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏á‡πà‡∏≤‡∏¢, forward rolling ‡∏à‡∏£‡∏¥‡∏á, reproducible, ‡πÑ‡∏°‡πà black box

---

````python
import pandas as pd
import numpy as np
import yfinance as yf
import streamlit as st
import math
import json
from datetime import datetime
from typing import List, Tuple, Dict, Any

from numba import njit
from functools import lru_cache

# ==============================================================================
# 1. Configuration & Constants
# ==============================================================================

class Strategy:
    REBALANCE_DAILY = "Rebalance Daily"
    PERFECT_FORESIGHT = "Perfect Foresight (Max)"

def load_config(filepath: str = "dynamic_seed_config.json") -> Dict[str, Any]:
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        st.warning(f"‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏ü‡∏•‡πå '{filepath}' ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏ó‡∏ô")
        return {
            "assets": ["FFWM", "NEGG", "RIVN", "BTC-USD", "NVDA"],
            "default_settings": {
                "selected_ticker": "FFWM", "start_date": "2024-01-01", "window_size": 30,
            }
        }

def initialize_session_state(config: Dict[str, Any]):
    defaults = config.get('default_settings', {})

    if 'test_ticker' not in st.session_state:
        st.session_state.test_ticker = defaults.get('selected_ticker', 'FFWM')
    if 'start_date' not in st.session_state:
        try:
            st.session_state.start_date = datetime.strptime(defaults.get('start_date', '2024-01-01'), '%Y-%m-%d').date()
        except ValueError:
            st.session_state.start_date = datetime(2024, 1, 1).date()
    if 'end_date' not in st.session_state:
        st.session_state.end_date = datetime.now().date()
    if 'window_size' not in st.session_state:
        st.session_state.window_size = defaults.get('window_size', 30)

# ==============================================================================
# 2. Core Calculation & Data Functions (With Numba Acceleration)
# ==============================================================================

@st.cache_data(ttl=3600)
def get_ticker_data(ticker: str, start_date: str, end_date: str) -> pd.DataFrame:
    try:
        data = yf.Ticker(ticker).history(start=start_date, end=end_date)[['Close']]
        if data.empty: return pd.DataFrame()
        # Standardize timezone to avoid issues
        if data.index.tz is None:
            data = data.tz_localize('UTC').tz_convert('Asia/Bangkok')
        else:
            data = data.tz_convert('Asia/Bangkok')
        return data
    except Exception as e:
        st.error(f"‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• {ticker} ‡πÑ‡∏î‡πâ: {str(e)}")
        return pd.DataFrame()

@njit(cache=True)
def _calculate_simulation_numba(action_array: np.ndarray, price_array: np.ndarray, fix: int = 1500) -> Tuple:
    n = len(action_array)
    if n == 0 or len(price_array) == 0:
        empty_arr = np.empty(0, dtype=np.float64)
        return (empty_arr, empty_arr, empty_arr, empty_arr, empty_arr, empty_arr)
    action_array_calc = action_array.copy()
    if n > 0: action_array_calc[0] = 1
    amount = np.empty(n, dtype=np.float64)
    buffer = np.zeros(n, dtype=np.float64)
    cash = np.empty(n, dtype=np.float64)
    asset_value = np.empty(n, dtype=np.float64)
    sumusd = np.empty(n, dtype=np.float64)
    initial_price = price_array[0]
    amount[0] = fix / initial_price
    cash[0] = fix
    asset_value[0] = amount[0] * initial_price
    sumusd[0] = cash[0] + asset_value[0]
    refer = -fix * np.log(initial_price / price_array)
    for i in range(1, n):
        curr_price = price_array[i]
        if action_array_calc[i] == 0:
            amount[i] = amount[i-1]
            buffer[i] = 0.0
        else:
            amount[i] = fix / curr_price
            buffer[i] = amount[i-1] * curr_price - fix
        cash[i] = cash[i-1] + buffer[i]
        asset_value[i] = amount[i] * curr_price
        sumusd[i] = cash[i] + asset_value[i]
    return buffer, sumusd, cash, asset_value, amount, refer

@lru_cache(maxsize=8192)
def calculate_optimized_cached(action_tuple: Tuple[int, ...], price_tuple: Tuple[float, ...], fix: int = 1500) -> Tuple:
    action_array = np.asarray(action_tuple, dtype=np.int32)
    price_array = np.asarray(price_tuple, dtype=np.float64)
    return _calculate_simulation_numba(action_array, price_array, fix)

def run_simulation(prices: List[float], actions: List[int], fix: int = 1500) -> pd.DataFrame:
    if not prices or not actions: return pd.DataFrame()
    min_len = min(len(prices), len(actions))
    prices = prices[:min_len]
    actions = actions[:min_len]
    buffer, sumusd, cash, asset_value, amount, refer = calculate_optimized_cached(tuple(actions), tuple(prices), fix)
    if len(sumusd) == 0: return pd.DataFrame()
    initial_capital = sumusd[0]
    return pd.DataFrame({
        'price': prices,
        'action': actions,
        'buffer': np.round(buffer, 2),
        'sumusd': np.round(sumusd, 2),
        'cash': np.round(cash, 2),
        'asset_value': np.round(asset_value, 2),
        'amount': np.round(amount, 2),
        'refer': np.round(refer + initial_capital, 2),
        'net': np.round(sumusd - refer - initial_capital, 2)
    })

# ==============================================================================
# 3. Standard & Benchmark Strategies
# ==============================================================================

def generate_actions_rebalance_daily(num_days: int) -> np.ndarray:
    return np.ones(num_days, dtype=np.int32)

def generate_actions_perfect_foresight(prices: List[float], fix: int = 1500) -> np.ndarray:
    price_arr = np.asarray(prices, dtype=np.float64)
    n = len(price_arr)
    if n < 2: return np.ones(n, dtype=int)
    dp = np.zeros(n, dtype=np.float64)
    path = np.zeros(n, dtype=int)
    dp[0] = float(fix * 2)
    for i in range(1, n):
        j_indices = np.arange(i)
        profits = fix * ((price_arr[i] / price_arr[j_indices]) - 1)
        current_sumusd = dp[j_indices] + profits
        best_idx = np.argmax(current_sumusd)
        dp[i] = current_sumusd[best_idx]
        path[i] = j_indices[best_idx]
    actions = np.zeros(n, dtype=int)
    current_day = np.argmax(dp)
    while current_day > 0:
        actions[current_day] = 1
        current_day = path[current_day]
    actions[0] = 1
    return actions

# ==============================================================================
# 4. New Model: Dynamic Threshold Rebalancing
# ==============================================================================

def generate_actions_dynamic_threshold(prices: List[float], window_size: int, threshold_pct: float) -> np.ndarray:
    n = len(prices)
    actions = np.zeros(n, dtype=int)
    actions[0] = 1
    for i in range(1, n):
        if i < window_size:
            rolling_mean = np.mean(prices[:i])
        else:
            rolling_mean = np.mean(prices[i-window_size:i])
        if rolling_mean == 0: continue
        deviation = (prices[i] - rolling_mean) / rolling_mean * 100
        actions[i] = 1 if abs(deviation) > threshold_pct else 0
    return actions

# ==============================================================================
# 5. UI Rendering Functions
# ==============================================================================

def render_settings_tab(config: Dict[str, Any]):
    st.write("‚öôÔ∏è **‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå**")
    asset_list = config.get('assets', ['FFWM'])
    try:
        default_index = asset_list.index(st.session_state.test_ticker)
    except ValueError:
        default_index = 0
    st.session_state.test_ticker = st.selectbox("‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Ticker ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö", options=asset_list, index=default_index)
    st.write("üìÖ **‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå**")
    col1, col2 = st.columns(2)
    with col1:
        st.session_state.start_date = st.date_input("‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô", value=st.session_state.start_date)
    with col2:
        st.session_state.end_date = st.date_input("‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î", value=st.session_state.end_date)
    if st.session_state.start_date >= st.session_state.end_date:
        st.error("‚ùå ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î")
    st.divider()
    st.subheader("‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ")
    st.session_state.window_size = st.number_input("‡∏Ç‡∏ô‡∏≤‡∏î Window (‡∏ß‡∏±‡∏ô)", min_value=2, value=st.session_state.window_size)

def display_comparison_charts(results: Dict[str, pd.DataFrame], chart_title: str = 'üìä ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Å‡∏≥‡πÑ‡∏£‡∏™‡∏∏‡∏ó‡∏ò‡∏¥ (Net Profit)'):
    if not results:
        st.warning("‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏£‡∏≤‡∏ü‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö")
        return
    valid_dfs = {name: df for name, df in results.items() if not df.empty and 'net' in df.columns}
    if not valid_dfs:
        st.warning("‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• 'net' ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏£‡∏≤‡∏ü")
        return
    try:
        longest_index = max((df.index for df in valid_dfs.values()), key=len, default=None)
    except ValueError:
        longest_index = None
    if longest_index is None:
        st.warning("‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏£‡∏≤‡∏ü‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö")
        return
    chart_data = pd.DataFrame(index=longest_index)
    for name, df in valid_dfs.items():
        chart_data[name] = df['net'].reindex(longest_index).ffill()
    st.write(chart_title)
    st.line_chart(chart_data)

def render_new_model_tab():
    st.write("---")
    st.markdown("### üöÄ New Model: Forward Rolling Dynamic Threshold Rebalancing")
    st.info("‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ rolling window ‡πÅ‡∏•‡∏∞ threshold ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì Rebalance ‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏Å‡∏•‡πâ Perfect Foresight (Max) ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏•‡πâ‡∏≥‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï")
    threshold = st.slider("Threshold (%)", min_value=1.0, max_value=20.0, value=5.0, step=0.5)
    window = st.number_input("Rolling Window Size", min_value=2, max_value=120, value=st.session_state.window_size)
    if st.button("üöÄ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå Dynamic Threshold"):
        ticker = st.session_state.test_ticker
        start_date_str = st.session_state.start_date.strftime('%Y-%m-%d')
        end_date_str = st.session_state.end_date.strftime('%Y-%m-%d')
        ticker_data = get_ticker_data(ticker, start_date_str, end_date_str)
        if ticker_data.empty:
            st.error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•")
            return
        prices = ticker_data['Close'].to_numpy()
        n = len(prices)
        actions_dynamic = generate_actions_dynamic_threshold(prices.tolist(), window_size=window, threshold_pct=threshold)
        actions_min = generate_actions_rebalance_daily(n)
        actions_max = generate_actions_perfect_foresight(prices.tolist())
        results = {
            "Dynamic Threshold": run_simulation(prices.tolist(), actions_dynamic.tolist()),
            Strategy.REBALANCE_DAILY: run_simulation(prices.tolist(), actions_min.tolist()),
            Strategy.PERFECT_FORESIGHT: run_simulation(prices.tolist(), actions_max.tolist())
        }
        for name, df in results.items():
            if not df.empty:
                df.index = ticker_data.index[:len(df)]
        st.success("‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå!")
        display_comparison_charts(results, chart_title="üìä Performance Comparison (Net Profit)")
        st.subheader("‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ (Final Net Profit)")
        metrics = []
        for name in results:
            if not results[name].empty:
                metrics.append((name, results[name]['net'].iloc[-1]))
        metric_cols = st.columns(len(metrics))
        for idx, (name, netval) in enumerate(metrics):
            metric_cols[idx].metric(name, f"${netval:,.2f}")

# ==============================================================================
# 6. Main Application
# ==============================================================================

def main():
    st.set_page_config(page_title="Best Seed Sliding Window", page_icon="üéØ", layout="wide")
    st.markdown("### üéØ Best Seed Sliding Window Tester (Optimized Edition)")
    st.caption("‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå Dynamic Threshold Rebalancing (Forward Rolling)")
    config = load_config()
    initialize_session_state(config)
    tab_list = [
        "‚öôÔ∏è ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤",
        "üöÄ New Model (Near Perfect Foresight)"
    ]
    tabs = st.tabs(tab_list)
    with tabs[0]: render_settings_tab(config)
    with tabs[1]: render_new_model_tab()
    with st.expander("üìñ ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô"):
        st.markdown("""
        ## New Model: Forward Rolling Dynamic Threshold Rebalancing
        - ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ rolling window ‡∏à‡∏≤‡∏Å‡∏≠‡∏î‡∏µ‡∏ï + threshold ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à rebalance
        - ‡πÄ‡∏õ‡πá‡∏ô forward rolling ‡∏à‡∏£‡∏¥‡∏á (‡πÑ‡∏°‡πà lookahead)
        - ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì seed/preset ‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏î‡πâ (threshold, window)
        - ‡πÑ‡∏°‡πà overfit, reproducible, ‡πÑ‡∏°‡πà black box
        - ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏™‡πâ‡∏ô Perfect Foresight (Max) ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏°‡∏µ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•
        """)

if __name__ == "__main__":
    main()
````

---

## **‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏à‡∏∏‡∏î‡πÄ‡∏î‡πà‡∏ô**
- **‡πÉ‡∏ä‡πâ‡∏á‡πà‡∏≤‡∏¢**: ‡πÅ‡∏Ñ‡πà‡∏™‡∏≠‡∏á‡πÅ‡∏ó‡πá‡∏ö ‡πÑ‡∏°‡πà‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô
- **‡πÄ‡∏£‡πá‡∏ß‡∏°‡∏≤‡∏Å**: Numba acceleration
- **‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÉ‡∏´‡∏°‡πà**: ‡πÉ‡∏ä‡πâ threshold + rolling mean, forward rolling ‡∏à‡∏£‡∏¥‡∏á
- **‡πÑ‡∏°‡πà overfit, ‡πÑ‡∏°‡πà black box**: ‡∏ó‡∏∏‡∏Å‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÑ‡∏î‡πâ, reproducible
- **‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Å‡∏±‡∏ö Benchmark**: ‡∏°‡∏µ‡∏ó‡∏±‡πâ‡∏á Rebalance Daily (Min) ‡πÅ‡∏•‡∏∞ Perfect Foresight (Max) ‡πÉ‡∏´‡πâ‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö

---

‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏™‡∏π‡∏ï‡∏£, ‡πÄ‡∏û‡∏¥‡πà‡∏° indicator, ‡∏´‡∏£‡∏∑‡∏≠‡∏õ‡∏£‡∏±‡∏ö UI ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° ‡πÅ‡∏à‡πâ‡∏á‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö!
