# ‡∏Å‡πà‡∏≠‡∏ô‡∏£‡∏±‡∏ô ‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á: pip install dtw-python
import pandas as pd
import numpy as np
import yfinance as yf
import streamlit as st
import math
import json
import ast
from concurrent.futures import ThreadPoolExecutor, as_completed
from functools import lru_cache
from datetime import datetime
from typing import List, Tuple, Dict, Any
from numba import njit
from dtw import dtw #! DTW: Import Dynamic Time Warping

# ==============================================================================
# 1. Configuration & Constants
# ==============================================================================

class Strategy:
    REBALANCE_DAILY = "Rebalance Daily"
    PERFECT_FORESIGHT = "Perfect Foresight (Max)"
    SLIDING_WINDOW = "Best Seed Sliding Window"
    CHAOTIC_SLIDING_WINDOW = "Chaotic Seed Sliding Window"
    MANUAL_SEED = "Manual Seed Strategy"
    GENETIC_ALGORITHM = "Genetic Algorithm Sliding Window"
    PATTERN_MATCHING_DTW = "Pattern Matching (DTW) Sliding Window"


def load_config(filepath: str = "dynamic_seed_config.json") -> Dict[str, Any]:
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        st.warning(f"‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏ü‡∏•‡πå '{filepath}' ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏ó‡∏ô")
        return {
            "assets": ["FFWM", "NEGG", "RIVN", "BTC-USD", "ETH-USD"],
            "default_settings": {
                "selected_ticker": "FFWM", "start_date": "2025-06-10", "window_size": 30, 
                "num_seeds": 30000, "max_workers": 8, 
                "ga_population_size": 50, "ga_generations": 20,
                "pm_lookback_period": 750, "pm_num_analogs": 5
            },
            "manual_seed_by_asset": {
                "default": [{'seed': 999, 'size': 50, 'tail': 15}],
                "FFWM": [{'seed': 1234, 'size': 60, 'tail': 30}, {'seed': 7777, 'size': 30, 'tail': 10}]
            }
        }

def on_ticker_change_callback(config: Dict[str, Any]):
    selected_ticker = st.session_state.get("manual_ticker_key")
    if not selected_ticker: return
    presets_by_asset = config.get("manual_seed_by_asset", {})
    default_presets = presets_by_asset.get("default", [{'seed': 999, 'size': 50, 'tail': 15}])
    st.session_state.manual_seed_lines = presets_by_asset.get(selected_ticker, default_presets)

def initialize_session_state(config: Dict[str, Any]):
    defaults = config.get('default_settings', {})
    if 'test_ticker' not in st.session_state: st.session_state.test_ticker = defaults.get('selected_ticker', 'FFWM')
    if 'start_date' not in st.session_state:
        try: st.session_state.start_date = datetime.strptime(defaults.get('start_date', '2025-01-01'), '%Y-%m-%d').date()
        except ValueError: st.session_state.start_date = datetime(2025, 1, 1).date()
    if 'end_date' not in st.session_state: st.session_state.end_date = datetime.now().date()
    if 'window_size' not in st.session_state: st.session_state.window_size = defaults.get('window_size', 30)
    if 'num_seeds' not in st.session_state: st.session_state.num_seeds = defaults.get('num_seeds', 30000)
    if 'max_workers' not in st.session_state: st.session_state.max_workers = defaults.get('max_workers', 8)
    if 'ga_population_size' not in st.session_state: st.session_state.ga_population_size = defaults.get('ga_population_size', 50)
    if 'ga_generations' not in st.session_state: st.session_state.ga_generations = defaults.get('ga_generations', 20)
    
    # Pattern Matching settings
    if 'pm_lookback_period' not in st.session_state: st.session_state.pm_lookback_period = defaults.get('pm_lookback_period', 750)
    if 'pm_num_analogs' not in st.session_state: st.session_state.pm_num_analogs = defaults.get('pm_num_analogs', 5)

    if 'df_for_analysis' not in st.session_state: st.session_state.df_for_analysis = None
    if 'manual_seed_lines' not in st.session_state:
        initial_ticker = defaults.get('selected_ticker', 'FFWM')
        presets_by_asset = config.get("manual_seed_by_asset", {})
        default_presets = presets_by_asset.get("default", [{'seed': 999, 'size': 50, 'tail': 15}])
        st.session_state.manual_seed_lines = presets_by_asset.get(initial_ticker, default_presets)

# ==============================================================================
# 2. Core Calculation & Data Functions (No Changes)
# ==============================================================================
@st.cache_data(ttl=3600)
def get_ticker_data(ticker: str, start_date: str, end_date: str) -> pd.DataFrame:
    try:
        data = yf.Ticker(ticker).history(start=start_date, end=end_date)[['Close']]
        if data.empty: return pd.DataFrame()
        if data.index.tz is None:
            data = data.tz_localize('UTC').tz_convert('Asia/Bangkok')
        else:
            data = data.tz_convert('Asia/Bangkok')
        return data
    except Exception as e:
        st.error(f"‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• {ticker} ‡πÑ‡∏î‡πâ: {str(e)}")
        return pd.DataFrame()

@njit(cache=True)
def _calculate_simulation_numba(action_array: np.ndarray, price_array: np.ndarray, fix: int = 1500) -> Tuple:
    n = len(action_array)
    if n == 0 or len(price_array) == 0:
        empty_arr = np.empty(0, dtype=np.float64)
        return (empty_arr, empty_arr, empty_arr, empty_arr, empty_arr, empty_arr)
    action_array_calc = action_array.copy()
    if n > 0: action_array_calc[0] = 1
    amount = np.empty(n, dtype=np.float64)
    buffer = np.zeros(n, dtype=np.float64)
    cash = np.empty(n, dtype=np.float64)
    asset_value = np.empty(n, dtype=np.float64)
    sumusd = np.empty(n, dtype=np.float64)
    initial_price = price_array[0]
    amount[0] = fix / initial_price
    cash[0] = fix
    asset_value[0] = amount[0] * initial_price
    sumusd[0] = cash[0] + asset_value[0]
    refer = -fix * np.log(initial_price / price_array)
    for i in range(1, n):
        curr_price = price_array[i]
        if action_array_calc[i] == 0:
            amount[i] = amount[i-1]
            buffer[i] = 0.0
        else:
            amount[i] = fix / curr_price
            buffer[i] = amount[i-1] * curr_price - fix
        cash[i] = cash[i-1] + buffer[i]
        asset_value[i] = amount[i] * curr_price
        sumusd[i] = cash[i] + asset_value[i]
    return buffer, sumusd, cash, asset_value, amount, refer

@lru_cache(maxsize=4096)
def calculate_optimized_cached(action_tuple: Tuple[int, ...], price_tuple: Tuple[float, ...], fix: int = 1500) -> Tuple:
    action_array = np.asarray(action_tuple, dtype=np.int32)
    price_array = np.asarray(price_tuple, dtype=np.float64)
    return _calculate_simulation_numba(action_array, price_array, fix)

def run_simulation(prices: List[float], actions: List[int], fix: int = 1500) -> pd.DataFrame:
    if not prices or not actions: return pd.DataFrame()
    prices, actions = prices[:len(actions)], actions[:len(prices)]
    action_array = np.asarray(actions, dtype=np.int32)
    price_array = np.asarray(prices, dtype=np.float64)
    buffer, sumusd, cash, asset_value, amount, refer = _calculate_simulation_numba(action_array, price_array, fix)
    if len(sumusd) == 0: return pd.DataFrame()
    initial_capital = sumusd[0]
    df = pd.DataFrame({
        'price': prices, 'action': actions, 'buffer': np.round(buffer, 2),
        'sumusd': np.round(sumusd, 2), 'cash': np.round(cash, 2),
        'asset_value': np.round(asset_value, 2), 'amount': np.round(amount, 2),
        'refer': np.round(refer + initial_capital, 2),
        'net': np.round(sumusd - refer - initial_capital, 2)
    })
    return df

# ==============================================================================
# 3. Strategy Action Generation
# ==============================================================================
# --- OMITTED FOR BREVITY: All functions for Benchmarks, Random Seed, Chaotic, GA are here ---
# 3.0 Benchmarks
def generate_actions_rebalance_daily(num_days: int) -> np.ndarray: return np.ones(num_days, dtype=np.int32)
@njit(cache=True)
def generate_actions_perfect_foresight(price_arr: np.ndarray, fix: int = 1500) -> np.ndarray:
    n = len(price_arr)
    if n < 2: return np.ones(n, dtype=np.int32)
    dp = np.zeros(n, dtype=np.float64); path = np.zeros(n, dtype=np.int32)
    dp[0] = float(fix * 2)
    for i in range(1, n):
        j_indices = np.arange(i); profits = fix * ((price_arr[i] / price_arr[j_indices]) - 1.0)
        current_sumusd = dp[j_indices] + profits; best_idx = np.argmax(current_sumusd)
        dp[i] = current_sumusd[best_idx]; path[i] = j_indices[best_idx]
    actions = np.zeros(n, dtype=np.int32); best_final_day = np.argmax(dp); current_day = best_final_day
    while current_day > 0: actions[current_day] = 1; current_day = path[current_day]
    actions[0] = 1
    return actions

# 3.1 & 3.2 & 3.3 ... All functions from previous steps are assumed to be here
# To save space, I will skip pasting them again. The new model is self-contained.

# 3.4 [NEW] Pattern Matching (DTW) Generation
@lru_cache(maxsize=1024)
def find_best_historical_analogs_dtw(target_pattern: tuple, historical_data: tuple, window_size: int, num_analogs: int) -> list:
    """Finds the best historical analogs using Dynamic Time Warping."""
    target_pattern = np.array(target_pattern)
    historical_data = np.array(historical_data)
    
    distances = []
    # Loop through historical data to find similar patterns
    for i in range(len(historical_data) - window_size):
        historical_pattern = historical_data[i : i + window_size]
        # Normalize patterns to compare shapes, not absolute values
        normalized_target = target_pattern / target_pattern[0]
        normalized_historical = historical_pattern / historical_pattern[0]
        
        # Calculate DTW distance
        distance = dtw(normalized_target, normalized_historical, keep_internals=True).distance
        
        # We need to know what happened *after* this historical pattern
        future_start = i + window_size
        future_end = future_start + window_size
        if future_end <= len(historical_data):
            distances.append((distance, future_start, future_end))
    
    # Sort by distance (smaller is better) and take the top N
    distances.sort(key=lambda x: x[0])
    return distances[:num_analogs]

def generate_actions_sliding_window_pattern_matching(
    ticker_data: pd.DataFrame, 
    window_size: int, 
    lookback_period: int, 
    num_analogs: int
) -> Tuple[np.ndarray, pd.DataFrame]:
    
    all_prices = ticker_data['Close'].to_numpy()
    n = len(all_prices)
    final_actions = np.array([], dtype=np.int32)
    window_details_list = []
    
    num_windows = (n - lookback_period) // window_size
    if num_windows <= 0:
        st.error(f"‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Lookback Period ({lookback_period}) ‡πÅ‡∏•‡∏∞ Window Size ({window_size}) ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏î‡∏Ñ‡πà‡∏≤ Lookback Period ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•")
        return np.array([]), pd.DataFrame()

    progress_bar = st.progress(0, text="‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏£‡∏≤‡∏Ñ‡∏≤‡πÉ‡∏ô‡∏≠‡∏î‡∏µ‡∏ï (Pattern Matching)...")
    
    # We can only start predicting after the lookback_period
    for i, start_index in enumerate(range(lookback_period, n, window_size)):
        end_index = min(start_index + window_size, n)
        if end_index - start_index < window_size: continue # Skip partial windows at the end

        # 1. Define target pattern and historical search space
        target_pattern = all_prices[start_index:end_index]
        historical_data = all_prices[:start_index]

        # 2. Find best analogs from history
        analogs = find_best_historical_analogs_dtw(
            tuple(target_pattern), 
            tuple(historical_data), 
            window_size, 
            num_analogs
        )
        
        # 3. For each analog, find its "perfect future" action sequence
        future_actions_candidates = []
        if analogs:
            for _, future_start, future_end in analogs:
                future_prices = historical_data[future_start:future_end]
                if len(future_prices) == window_size:
                    # Find the best possible actions for that future
                    perfect_actions = generate_actions_perfect_foresight(future_prices)
                    future_actions_candidates.append(perfect_actions)

        # 4. Combine the candidates into a single action sequence (Voting)
        if future_actions_candidates:
            # Stack candidates and take the mode (most frequent value) for each day
            stacked_actions = np.vstack(future_actions_candidates)
            # scipy.stats.mode is better, but np.mean avoids a new dependency
            # A mean > 0.5 means '1' was more common than '0'
            voted_actions = (np.mean(stacked_actions, axis=0) > 0.5).astype(int)
            voted_actions[0] = 1 # Ensure first action is always 1
        else:
            # If no analogs found, default to rebalancing daily
            voted_actions = np.ones(window_size, dtype=np.int32)

        final_actions = np.concatenate((final_actions, voted_actions))
        
        # Calculate Net for reporting
        _, sumusd, _, _, _, refer = calculate_optimized_cached(tuple(voted_actions), tuple(target_pattern))
        max_net = sumusd[-1] - refer[-1] - sumusd[0] if len(sumusd) > 0 else 0.0
        
        start_date_str = ticker_data.index[start_index].strftime('%Y-%m-%d')
        end_date_str = ticker_data.index[end_index-1].strftime('%Y-%m-%d')
        detail = {
            'window_number': i + 1, 'timeline': f"{start_date_str} ‡∏ñ‡∏∂‡∏á {end_date_str}", 'max_net': round(max_net, 2),
            'price_change_pct': round(((target_pattern[-1] / target_pattern[0]) - 1) * 100, 2),
            'action_count': int(np.sum(voted_actions)), 'analogs_found': len(future_actions_candidates),
            'window_size': window_len, 'action_sequence': voted_actions.tolist()
        }
        window_details_list.append(detail)
        progress_bar.progress((i + 1) / num_windows, text=f"Analyzing Window {i+1}/{num_windows}")
        
    progress_bar.empty()
    return final_actions, pd.DataFrame(window_details_list)


# ==============================================================================
# 4. UI Rendering Functions
# ==============================================================================
def render_settings_tab(config: Dict[str, Any]):
    st.write("‚öôÔ∏è **‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå**")
    asset_list = config.get('assets', ['FFWM']); default_index = asset_list.index(st.session_state.test_ticker) if st.session_state.test_ticker in asset_list else 0
    st.session_state.test_ticker = st.selectbox("‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Ticker ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö", options=asset_list, index=default_index)
    
    st.write("üìÖ **‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå**")
    col1, col2 = st.columns(2)
    with col1: st.session_state.start_date = st.date_input("‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô", value=st.session_state.start_date)
    with col2: st.session_state.end_date = st.date_input("‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î", value=st.session_state.end_date)
    
    if st.session_state.start_date >= st.session_state.end_date: st.error("‚ùå ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î")
    else: st.info(f"‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å: {st.session_state.start_date:%Y-%m-%d} ‡∏ñ‡∏∂‡∏á {st.session_state.end_date:%Y-%m-%d}")
    
    st.divider()
    
    st.subheader("‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ")
    c1, c2 = st.columns(2)
    st.session_state.window_size = c1.number_input("‡∏Ç‡∏ô‡∏≤‡∏î Window (‡∏ß‡∏±‡∏ô)", min_value=10, value=st.session_state.window_size)
    st.session_state.max_workers = c2.number_input("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Workers (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Random/Chaotic)", min_value=1, max_value=16, value=st.session_state.max_workers)

    st.subheader("‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Random/Chaotic Seed")
    st.session_state.num_seeds = st.number_input("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Seeds/Params ‡∏ï‡πà‡∏≠ Window", min_value=100, value=st.session_state.num_seeds, format="%d")
    
    st.subheader("‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Genetic Algorithm")
    ga_c1, ga_c2 = st.columns(2)
    st.session_state.ga_population_size = ga_c1.number_input("‡∏Ç‡∏ô‡∏≤‡∏î‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏Å‡∏£ (Population Size)", min_value=10, value=st.session_state.ga_population_size)
    st.session_state.ga_generations = ga_c2.number_input("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏£‡∏∏‡πà‡∏ô (Generations)", min_value=5, value=st.session_state.ga_generations)
    
    st.subheader("‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Pattern Matching (DTW)")
    pm_c1, pm_c2 = st.columns(2)
    st.session_state.pm_lookback_period = pm_c1.number_input("‡∏ä‡πà‡∏ß‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏≠‡∏î‡∏µ‡∏ï‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ (‡∏ß‡∏±‡∏ô)", min_value=100, value=st.session_state.pm_lookback_period, help="‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏Ñ‡∏•‡πâ‡∏≤‡∏¢‡∏Å‡∏±‡∏ô ‡∏¢‡∏¥‡πà‡∏á‡∏°‡∏≤‡∏Å‡∏¢‡∏¥‡πà‡∏á‡∏î‡∏µ‡πÅ‡∏ï‡πà‡∏à‡∏∞‡∏ä‡πâ‡∏≤‡∏•‡∏á")
    st.session_state.pm_num_analogs = pm_c2.number_input("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏Ñ‡∏•‡πâ‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÉ‡∏ä‡πâ (Analogs)", min_value=1, max_value=20, value=st.session_state.pm_num_analogs, help="‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏Ñ‡∏•‡πâ‡∏≤‡∏¢‡∏Å‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡∏≠‡∏î‡∏µ‡∏ï‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ô‡∏≥‡∏°‡∏≤‡∏•‡∏á‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à")


def display_comparison_charts(results: Dict[str, pd.DataFrame], chart_title: str = 'üìä ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Å‡∏≥‡πÑ‡∏£‡∏™‡∏∏‡∏ó‡∏ò‡∏¥ (Net Profit)'):
    if not results: st.warning("‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏£‡∏≤‡∏ü‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö"); return
    try: longest_index = max((df.index for name, df in results.items() if not df.empty and 'net' in df.columns), key=len, default=None)
    except ValueError: longest_index = None
    if longest_index is None: st.warning("‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏£‡∏≤‡∏ü‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö"); return
    chart_data = pd.DataFrame(index=longest_index)
    for name, df in results.items():
        if not df.empty and 'net' in df.columns:
            chart_data[name] = df['net'].reindex(longest_index).ffill()
    st.write(chart_title); st.line_chart(chart_data)


def run_and_display_strategy(strategy_func, strategy_args: Dict, strategy_name: str, full_ticker_data: pd.DataFrame, df_columns_to_show: List[str]):
    button_key = f"btn_{strategy_name.replace(' ', '_').replace('(', '').replace(')', '')}"
    if st.button(f"üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏î‡∏™‡∏≠‡∏ö ({strategy_name})", type="primary", key=button_key):
        if st.session_state.start_date >= st.session_state.end_date:
            st.error("‚ùå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ô‡πÅ‡∏ó‡πá‡∏ö '‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤'"); return
        
        with st.spinner(f"‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå {strategy_name}..."):
            # For Pattern Matching, we need a larger dataset including the lookback period
            if strategy_name == Strategy.PATTERN_MATCHING_DTW:
                test_data = full_ticker_data
                prices_for_sim = test_data['Close'].to_numpy()[st.session_state.pm_lookback_period:]
                sim_dates = test_data.index[st.session_state.pm_lookback_period:]
            else:
                test_data = full_ticker_data
                prices_for_sim = test_data['Close'].to_numpy()
                sim_dates = test_data.index

            main_actions, df_windows = strategy_func(ticker_data=test_data, **strategy_args)
            
            num_days = len(prices_for_sim)
            if num_days == 0 or len(main_actions) == 0:
                st.error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÑ‡∏î‡πâ ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô"); return

            actions_min = generate_actions_rebalance_daily(num_days)
            actions_max = generate_actions_perfect_foresight(prices_for_sim)

            results_map = {
                strategy_name: main_actions.tolist(),
                Strategy.REBALANCE_DAILY: actions_min.tolist(),
                Strategy.PERFECT_FORESIGHT: actions_max.tolist()
            }
            sim_results = {}
            for name, actions in results_map.items():
                df = run_simulation(prices_for_sim.tolist(), actions)
                if not df.empty: df.index = sim_dates[:len(df)]
                sim_results[name] = df
        
        st.success("‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå!")
        st.write("---"); display_comparison_charts(sim_results, f"‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö: {strategy_name}")
        st.write(f"üìà **‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ ({strategy_name})**")
        
        if df_windows is not None and not df_windows.empty:
            total_actions = df_windows['action_count'].sum(); total_net = df_windows['max_net'].sum()
            col1, col2, col3 = st.columns(3)
            col1.metric("Total Windows", df_windows.shape[0])
            col2.metric("Total Actions", f"{total_actions}/{num_days}")
            col3.metric("Total Net (Sum)", f"${total_net:,.2f}")
            st.dataframe(df_windows[df_columns_to_show], use_container_width=True)
            csv = df_windows.to_csv(index=False)
            st.download_button(label=f"üì• ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î {strategy_name} Details (CSV)", data=csv, file_name=f'{strategy_name.replace(" ", "_")}_{st.session_state.test_ticker}_{st.session_state.window_size}w.csv', mime='text/csv')
        else:
            st.warning("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏£‡∏∏‡∏õ Window ‡πÑ‡∏î‡πâ")

# --- UI Rendering for each Tab ---
def render_test_tab(ticker_data): # Random Seed
    st.markdown("### üé≤ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö Best Seed ‡∏î‡πâ‡∏ß‡∏¢ Random Search")
    st.info("‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏™‡∏∏‡πà‡∏° `seed` ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏°‡∏≤‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤‡∏•‡∏≥‡∏î‡∏±‡∏ö Action ‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞ Window")
    if ticker_data.empty: st.error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Ticker ‡πÅ‡∏•‡∏∞‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å"); return
    args = {'window_size': st.session_state.window_size, 'num_seeds_to_try': st.session_state.num_seeds, 'max_workers': st.session_state.max_workers}
    columns_to_show = ['window_number', 'timeline', 'best_seed', 'max_net', 'price_change_pct', 'action_count']
    run_and_display_strategy(generate_actions_sliding_window, args, Strategy.SLIDING_WINDOW, ticker_data, columns_to_show)

def render_chaotic_test_tab(ticker_data):
    st.markdown("### üåÄ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö Best Seed ‡∏î‡πâ‡∏ß‡∏¢ Chaotic Generator")
    st.info("‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå `r` ‡πÅ‡∏•‡∏∞ `x0` ‡∏Ç‡∏≠‡∏á Logistic Map ‡∏ó‡∏µ‡πà‡πÉ‡∏´‡πâ‡∏ú‡∏•‡∏ï‡∏≠‡∏ö‡πÅ‡∏ó‡∏ô‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞ Window")
    if ticker_data.empty: st.error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Ticker ‡πÅ‡∏•‡∏∞‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å"); return
    args = {'window_size': st.session_state.window_size, 'num_seeds_to_try': st.session_state.num_seeds, 'max_workers': st.session_state.max_workers}
    columns_to_show = ['window_number', 'timeline', 'best_seed', 'r_param', 'x0_param', 'max_net', 'price_change_pct', 'action_count']
    run_and_display_strategy(generate_actions_sliding_window_chaotic, args, Strategy.CHAOTIC_SLIDING_WINDOW, ticker_data, columns_to_show)

def render_ga_test_tab(ticker_data):
    st.markdown("### üß¨ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏î‡πâ‡∏ß‡∏¢ Genetic Algorithm Search")
    st.info("‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏¥‡∏á‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì (GA) ‡πÄ‡∏û‡∏∑‡πà‡∏≠ '‡∏û‡∏±‡∏í‡∏ô‡∏≤' Action Sequence ‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞ Window")
    if ticker_data.empty: st.error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Ticker ‡πÅ‡∏•‡∏∞‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å"); return
    args = {'window_size': st.session_state.window_size, 'population_size': st.session_state.ga_population_size, 'generations': st.session_state.ga_generations}
    columns_to_show = ['window_number', 'timeline', 'max_net', 'price_change_pct', 'action_count']
    run_and_display_strategy(generate_actions_sliding_window_ga, args, Strategy.GENETIC_ALGORITHM, ticker_data, columns_to_show)

def render_pattern_matching_tab(ticker_data):
    st.markdown("### üîç ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏î‡πâ‡∏ß‡∏¢ Pattern Matching (DTW)")
    st.info("‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏£‡∏≤‡∏Ñ‡∏≤‡πÉ‡∏ô‡∏≠‡∏î‡∏µ‡∏ï‡∏ó‡∏µ‡πà‡∏Ñ‡∏•‡πâ‡∏≤‡∏¢‡∏Å‡∏±‡∏ö‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î ‡πÅ‡∏•‡πâ‡∏ß‡∏ô‡∏≥ Action ‡∏ó‡∏µ‡πà‡πÄ‡∏Ñ‡∏¢‡πÉ‡∏´‡πâ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï‡∏Ç‡∏≠‡∏á‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ô‡∏±‡πâ‡∏ô‡∏°‡∏≤‡πÉ‡∏ä‡πâ")
    if ticker_data.empty: st.error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Ticker ‡πÅ‡∏•‡∏∞‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å"); return
    args = {'window_size': st.session_state.window_size, 'lookback_period': st.session_state.pm_lookback_period, 'num_analogs': st.session_state.pm_num_analogs}
    columns_to_show = ['window_number', 'timeline', 'max_net', 'price_change_pct', 'action_count', 'analogs_found']
    run_and_display_strategy(generate_actions_sliding_window_pattern_matching, args, Strategy.PATTERN_MATCHING_DTW, ticker_data, columns_to_show)

# ... The render_analytics_tab and render_manual_seed_tab are omitted for brevity ...
def render_analytics_tab(): st.header("üìä Advanced Analytics Dashboard (Omitted)"); st.info("This tab is for analyzing saved CSV files.")
def render_manual_seed_tab(config): st.header("üå± Manual/Forward Testing (Omitted)"); st.info("This tab is for testing custom seeds.")

# ==============================================================================
# 5. Main Application
# ==============================================================================
def main():
    st.set_page_config(page_title="Strategy Optimization Lab", page_icon="üéØ", layout="wide")
    st.markdown("## üéØ Strategy Optimization Lab")
    st.caption("‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏Å‡∏≤‡∏£‡∏•‡∏á‡∏ó‡∏∏‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡∏ß‡∏¥‡∏ò‡∏µ Sliding Window")

    config = load_config()
    initialize_session_state(config)

    tab_list = ["‚öôÔ∏è ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤", "üé≤ Random Seed", "üåÄ Chaotic Seed", "üß¨ GA Search", "üîç Pattern Matching", "üìä Analytics", "üå± Manual/Forward"]
    tabs = st.tabs(tab_list)

    # Fetch data once for all tabs to use
    # For Pattern Matching, we need to fetch more data to serve as the historical lookback
    start_date_obj = st.session_state.start_date
    pm_lookback_days = st.session_state.pm_lookback_period
    data_fetch_start_date = (start_date_obj - pd.Timedelta(days=pm_lookback_days * 1.5)).strftime('%Y-%m-%d') # Fetch 1.5x to account for non-trading days
    full_ticker_data = get_ticker_data(st.session_state.test_ticker, data_fetch_start_date, st.session_state.end_date.strftime('%Y-%m-%d'))
    
    # Filter data for non-pattern matching tabs
    standard_ticker_data = full_ticker_data.loc[full_ticker_data.index.date >= start_date_obj]

    with tabs[0]: render_settings_tab(config)
    with tabs[1]: render_test_tab(standard_ticker_data)
    with tabs[2]: render_chaotic_test_tab(standard_ticker_data)
    with tabs[3]: render_ga_test_tab(standard_ticker_data)
    with tabs[4]: render_pattern_matching_tab(full_ticker_data) # This tab needs the full dataset
    with tabs[5]: render_analytics_tab()
    with tabs[6]: render_manual_seed_tab(config)

    with st.expander("üìñ ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡πÅ‡∏•‡∏∞‡πÅ‡∏ô‡∏ß‡∏Ñ‡∏¥‡∏î"):
        st.markdown("""
        **‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô:** ‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ö‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£ "Sliding Window" ‡∏Ñ‡∏∑‡∏≠‡πÅ‡∏ö‡πà‡∏á‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏≠‡∏≠‡∏Å‡πÄ‡∏õ‡πá‡∏ô "‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á" ‡πÄ‡∏•‡πá‡∏Å‡πÜ ‡πÅ‡∏•‡πâ‡∏ß‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏´‡∏≤ "‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥" (Action Sequence) ‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡∏ô‡∏±‡πâ‡∏ô‡πÜ ‡∏Å‡πà‡∏≠‡∏ô‡∏à‡∏∞‡∏ô‡∏≥‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Ç‡∏≠‡∏á‡∏ó‡∏∏‡∏Å‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡∏°‡∏≤‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö‡∏Å‡∏±‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢

        ---
        #### ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ (Search Strategies)
        *   **üé≤ Random Seed:** ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏∏‡πà‡∏° Action Sequence ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏°‡∏≤‡∏Å
        *   **üåÄ Chaotic Seed:** ‡πÉ‡∏ä‡πâ "Logistic Map" ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Action Sequence ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô
        *   **üß¨ Genetic Algorithm:** ‡πÄ‡∏•‡∏µ‡∏¢‡∏ô‡πÅ‡∏ö‡∏ö‡∏ß‡∏¥‡∏ß‡∏±‡∏í‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡∏ó‡∏≤‡∏á‡∏ò‡∏£‡∏£‡∏°‡∏ä‡∏≤‡∏ï‡∏¥ ‡πÄ‡∏û‡∏∑‡πà‡∏≠ "‡∏û‡∏±‡∏í‡∏ô‡∏≤" Sequence ‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
        *   **üîç Pattern Matching (DTW):** **[‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÉ‡∏´‡∏°‡πà‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏™‡∏π‡∏á]** ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡∏ó‡∏µ‡πà‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏£‡∏≤‡∏Ñ‡∏≤‡πÉ‡∏ô‡∏≠‡∏î‡∏µ‡∏ï (Historical Analogs) ‡∏ó‡∏µ‡πà‡∏°‡∏µ "‡∏£‡∏π‡∏õ‡∏ó‡∏£‡∏á" ‡∏Ñ‡∏•‡πâ‡∏≤‡∏¢‡∏Å‡∏±‡∏ö‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏£‡∏≤‡∏Ñ‡∏≤‡πÉ‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ Dynamic Time Warping (DTW) ‡∏à‡∏≤‡∏Å‡∏ô‡∏±‡πâ‡∏ô‡∏à‡∏∞‡∏ô‡∏≥ Action Sequence ‡∏ó‡∏µ‡πà‡πÄ‡∏Ñ‡∏¢‡πÉ‡∏´‡πâ‡∏ú‡∏•‡∏ï‡∏≠‡∏ö‡πÅ‡∏ó‡∏ô‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï‡∏Ç‡∏≠‡∏á‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô‡∏°‡∏≤ "‡∏•‡∏á‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô" (Vote) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô Action ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô ‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏ó‡∏µ‡πà‡∏Ç‡∏±‡∏ö‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÅ‡∏ó‡πâ‡∏à‡∏£‡∏¥‡∏á

        ---
        #### ‡πÅ‡∏ó‡πá‡∏ö‡∏≠‡∏∑‡πà‡∏ô‡πÜ
        *   **üìä Analytics:** ‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÑ‡∏ü‡∏•‡πå‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå (.csv) ‡∏ó‡∏µ‡πà‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö
        *   **üå± Manual/Forward:** ‡πÉ‡∏ä‡πâ‡∏ó‡∏î‡∏™‡∏≠‡∏ö Action Sequence ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏à‡∏≤‡∏Å Seed ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á
        """)

if __name__ == "__main__":
    main()
